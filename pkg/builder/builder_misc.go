package builder

import (
	"k8s.io/apimachinery/pkg/runtime"
	genericapiserver "k8s.io/apiserver/pkg/server"
	"k8s.io/klog/v2"
	openapicommon "k8s.io/kube-openapi/pkg/common"
	"sigs.k8s.io/apiserver-runtime/internal/sample-apiserver/pkg/cmd/server"
	"sigs.k8s.io/apiserver-runtime/pkg/util/loopback"
)

// WithOpenAPIDefinitions registers resource OpenAPI definitions generated by openapi-gen.
//
//	export K8sAPIS=k8s.io/apimachinery/pkg/api/resource,\
//	  k8s.io/apimachinery/pkg/apis/meta/v1,\
//	  k8s.io/apimachinery/pkg/runtime,\
//	  k8s.io/apimachinery/pkg/version
//	export MY_APIS=my-go-pkg/pkg/apis/my-group/my-version
//	export OPENAPI=my-go-pkg/pkg/generated/openapi
//	openapi-gen --input-dirs $K8SAPIS,$MY_APIS --output-package $OPENAPI \
//	  -O zz_generated.openapi --output-base ../../.. --go-header-file ./hack/boilerplate.go.txt
func (a *Server) WithOpenAPIDefinitions(
	name, version string, openAPI openapicommon.GetOpenAPIDefinitions) *Server {
	server.SetOpenAPIDefinitions(name, version, openAPI)
	return a
}

// WithPostStartHook registers a post start hook which will be invoked after the apiserver is started
// and before it's ready for serving requests.
func (a *Server) WithPostStartHook(name string, hookFunc genericapiserver.PostStartHookFunc) *Server {
	a.WithServerFns(func(server *GenericAPIServer) *GenericAPIServer {
		if err := server.AddPostStartHook(name, hookFunc); err != nil {
			klog.Fatalf("failed registering post-start hook %v: %v", name, err)
		}
		return server
	})
	return a
}

// WithAdditionalSchemeInstallers registers functions to install additional functions or resources into the Scheme.
// This can be used to manually registering defaulting functions, conversion functions, or resource types, rather
// than registering them automatically by implementing the corresponding interfaces on the resources.
func (a *Server) WithAdditionalSchemeInstallers(fns ...func(*runtime.Scheme) error) *Server {
	a.schemeBuilder.Register(fns...)
	return a
}

// WithAdditionalSchemesToBuild will add types and functions to these Schemes in addition to the
// apiserver.Scheme.
// This can be used to register the resource types, defaulting functions, and conversion functions
// with additional Scheme's.
func (a *Server) WithAdditionalSchemesToBuild(s ...*runtime.Scheme) *Server {
	a.schemes = append(a.schemes, s...)
	return a
}

// ExposeLoopbackClientConfig exposes loopback client config as an external singleton.
func (a *Server) ExposeLoopbackClientConfig() *Server {
	return a.WithServerFns(func(c *GenericAPIServer) *GenericAPIServer {
		loopback.SetLoopbackClientConfig(c.LoopbackClientConfig)
		return c
	})
}

// ExposeLoopbackAuthorizer exposes loopback authorizer as an external singleton.
func (a *Server) ExposeLoopbackAuthorizer() *Server {
	return a.WithServerFns(func(s *GenericAPIServer) *GenericAPIServer {
		loopback.SetAuthorizer(s.Authorizer)
		return s
	})
}

// ExposeLoopbackMasterClientConfig exposes loopback client config for accessing the
// configured master cluster's kube-apiserver as an external singleton.
func (a *Server) ExposeLoopbackMasterClientConfig() *Server {
	return a.WithConfigFns(func(config *genericapiserver.RecommendedConfig) *genericapiserver.RecommendedConfig {
		loopback.SetLoopbackMasterClientConfig(config.ClientConfig)
		return config
	})
}

// WithoutEtcd removes etcd related settings from apiserver.
func (a *Server) WithoutEtcd() *Server {
	return a.WithOptionsFns(func(o *ServerOptions) *ServerOptions {
		o.RecommendedOptions.Etcd = nil
		return o
	})
}
